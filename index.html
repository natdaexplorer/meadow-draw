<script>
// DRAWING LOGIC
const canvas = document.getElementById("draw-area");
const ctx = canvas.getContext("2d");

// Set canvas size based on device
function setupCanvas() {
    if (window.innerWidth <= 768) {
        canvas.width = 250;
        canvas.height = 250;
    } else {
        canvas.width = 200;
        canvas.height = 200;
    }
    
    ctx.fillStyle = '#FFF9F0';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.lineWidth = 12;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
}

setupCanvas();

let drawing = false;
let currentColor = "#c43a3a";
let hasDrawing = false;
let loadedDrawingIds = new Set();
let lastSyncTime = 0;

// Enhanced localStorage with sync
function getPondItems() {
    return JSON.parse(localStorage.getItem('pondItems') || '[]');
}

function savePondItems(items) {
    localStorage.setItem('pondItems', JSON.stringify(items));
    // Update sync timestamp
    localStorage.setItem('lastUpdate', Date.now().toString());
}

// Cross-tab synchronization
function setupCrossTabSync() {
    window.addEventListener('storage', function(e) {
        if (e.key === 'pondItems' || e.key === 'lastUpdate') {
            setTimeout(loadPondItems, 100);
        }
    });
}

function selectColor(color, element) {
    currentColor = color;
    document.querySelectorAll('.color-dot').forEach(dot => {
        dot.classList.remove('selected');
    });
    element.classList.add('selected');
}

// ... (keep all your existing drawing functions - they're fine)
// Mouse events for desktop
canvas.addEventListener("mousedown", startDrawing);
canvas.addEventListener("mouseup", stopDrawing);
canvas.addEventListener("mouseout", stopDrawing);
canvas.addEventListener("mousemove", draw);

// Touch events for mobile
canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
canvas.addEventListener("touchend", handleTouchEnd);

function startDrawing(e) {
    drawing = true;
    hasDrawing = true;
    ctx.beginPath();
    const pos = getMousePos(e);
    ctx.moveTo(pos.x, pos.y);
    draw(e);
}

function stopDrawing() {
    drawing = false;
    ctx.beginPath();
}

function draw(e) {
    if (!drawing) return;
    
    const pos = getMousePos(e);
    ctx.strokeStyle = currentColor;
    ctx.lineTo(pos.x, pos.y);
    ctx.stroke();
    hasDrawing = true;
}

function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    let x, y;
    
    if (e.type.includes('touch')) {
        x = e.touches[0].clientX - rect.left;
        y = e.touches[0].clientY - rect.top;
    } else {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
    }
    
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    return {
        x: x * scaleX,
        y: y * scaleY
    };
}

function handleTouchStart(e) {
    e.preventDefault();
    drawing = true;
    hasDrawing = true;
    ctx.beginPath();
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent("mousedown", {
        clientX: touch.clientX,
        clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
}

function handleTouchMove(e) {
    e.preventDefault();
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent("mousemove", {
        clientX: touch.clientX,
        clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
}

function handleTouchEnd(e) {
    e.preventDefault();
    const mouseEvent = new MouseEvent("mouseup", {});
    canvas.dispatchEvent(mouseEvent);
}

function clearCanvas() {
    ctx.fillStyle = '#FFF9F0';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    hasDrawing = false;
}

function isCanvasBlank() {
    const blank = document.createElement('canvas');
    blank.width = canvas.width;
    blank.height = canvas.height;
    const blankCtx = blank.getContext('2d');
    blankCtx.fillStyle = '#FFF9F0';
    blankCtx.fillRect(0, 0, blank.width, blank.height);
    return canvas.toDataURL() === blank.toDataURL();
}

function typeWithPauses() {
    const toolTitle = document.getElementById('toolTitle');
    const message = "That's not a drawing. Try again?";
    toolTitle.innerHTML = '';
    
    let i = 0;
    function type() {
        if (i < message.length) {
            toolTitle.innerHTML += message.charAt(i);
            i++;
            setTimeout(type, 80);
        } else {
            setTimeout(() => {
                toolTitle.innerHTML = "Drop Something Into Our Pond?";
            }, 2000);
        }
    }
    type();
}

function showAddingMessage() {
    const addButton = document.getElementById('addButton');
    addButton.textContent = "Adding...";
    addButton.disabled = true;
    addButton.style.opacity = '0.7';
    
    let dots = 0;
    const maxDots = 3;
    
    function animateDots() {
        dots = (dots + 1) % (maxDots + 1);
        addButton.textContent = "Adding" + '.'.repeat(dots);
        if (dots < maxDots) {
            setTimeout(animateDots, 500);
        } else {
            setTimeout(() => {
                addButton.textContent = "üêü Add to Pond";
                addButton.disabled = false;
                addButton.style.opacity = '1';
            }, 500);
        }
    }
    animateDots();
}

function getRandomPondPosition() {
    const pondArea = {
        left: 15,
        right: 85,  
        top: 20,
        bottom: 80
    };
    
    return {
        x: Math.random() * (pondArea.right - pondArea.left) + pondArea.left,
        y: Math.random() * (pondArea.bottom - pondArea.top) + pondArea.top
    };
}

function generateDrawingId() {
    return 'drawing_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// ADD TO POND
async function addToPond() {
    if (isCanvasBlank()) {
        typeWithPauses();
        return;
    }
    
    showAddingMessage();
    
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    
    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
    
    const whiteCanvas = document.createElement('canvas');
    whiteCanvas.width = canvas.width;
    whiteCanvas.height = canvas.height;
    const whiteCtx = whiteCanvas.getContext('2d');
    whiteCtx.fillStyle = '#FFF9F0';
    whiteCtx.fillRect(0, 0, whiteCanvas.width, whiteCanvas.height);
    
    const originalData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const whiteData = whiteCtx.getImageData(0, 0, whiteCanvas.width, whiteCanvas.height);
    const newData = tempCtx.createImageData(canvas.width, canvas.height);
    
    for (let i = 0; i < originalData.data.length; i += 4) {
        const r1 = originalData.data[i];
        const g1 = originalData.data[i + 1];
        const b1 = originalData.data[i + 2];
        
        const r2 = whiteData.data[i];
        const g2 = whiteData.data[i + 1];
        const b2 = whiteData.data[i + 2];
        
        if (r1 !== r2 || g1 !== g2 || b1 !== b2) {
            newData.data[i] = r1;
            newData.data[i + 1] = g1;
            newData.data[i + 2] = b1;
            newData.data[i + 3] = 255;
        }
    }
    
    tempCtx.putImageData(newData, 0, 0);
    const imgData = tempCanvas.toDataURL('image/png');
    
    let items = getPondItems();
    const position = getRandomPondPosition();
    
    const newItem = {
        id: generateDrawingId(),
        img: imgData,
        x: position.x,
        y: position.y,
        timestamp: Date.now()
    };
    
    items.push(newItem);
    savePondItems(items);
    
    clearCanvas();
    
    // Add the new drawing immediately
    addSingleDrawing(newItem);
    
    // On mobile, hide tools and show pond after adding
    if (window.innerWidth <= 768) {
        setTimeout(() => {
            hideDrawingTools();
        }, 1500);
    }
}

// Add a single drawing to the pond
function addSingleDrawing(item) {
    const container = document.getElementById("pondDrawings");
    
    // Check if drawing already exists to prevent duplicates
    if (loadedDrawingIds.has(item.id)) {
        return;
    }
    
    let img = document.createElement("img");
    img.src = item.img;
    img.style.left = item.x + "%";
    img.style.top = item.y + "%";
    img.setAttribute('data-id', item.id);
    
    // Add click handler for desktop deletion (3 clicks)
    if (window.innerWidth > 768) {
        let clickCount = 0;
        img.addEventListener('click', function() {
            clickCount++;
            if (clickCount >= 3) {
                deleteDrawing(item.id);
                clickCount = 0;
            }
        });
    }
    
    container.appendChild(img);
    loadedDrawingIds.add(item.id);
}

// Delete drawing by ID
function deleteDrawing(id) {
    let items = getPondItems();
    items = items.filter(item => item.id !== id);
    savePondItems(items);
    
    // Remove from pond display
    const img = document.querySelector(`img[data-id="${id}"]`);
    if (img) {
        img.remove();
    }
    
    loadedDrawingIds.delete(id);
}

// LOAD POND ITEMS - Only load new items
async function loadPondItems() {
    const items = getPondItems();
    const container = document.getElementById("pondDrawings");
    
    // Find new items that haven't been loaded yet
    const newItems = items.filter(item => !loadedDrawingIds.has(item.id));
    
    if (newItems.length > 0) {
        newItems.forEach((item, index) => {
            setTimeout(() => {
                addSingleDrawing(item);
            }, index * 400); // Stagger the pop-up animations
        });
    }
}

// Enhanced real-time sync between tabs
function syncDrawings() {
    const items = getPondItems();
    const container = document.getElementById("pondDrawings");
    
    // Get current displayed drawing IDs
    const currentDisplayedIds = new Set();
    container.querySelectorAll('img[data-id]').forEach(img => {
        currentDisplayedIds.add(img.getAttribute('data-id'));
    });
    
    // Remove drawings that are no longer in localStorage
    container.querySelectorAll('img[data-id]').forEach(img => {
        const id = img.getAttribute('data-id');
        const existsInStorage = items.some(item => item.id === id);
        if (!existsInStorage) {
            img.remove();
            loadedDrawingIds.delete(id);
        }
    });
    
    // Add drawings that are in localStorage but not displayed
    items.forEach(item => {
        if (!currentDisplayedIds.has(item.id)) {
            addSingleDrawing(item);
        }
    });
}

// Mobile functionality
function showDrawingTools() {
    const toolsSection = document.getElementById('toolsSection');
    const mobileButtons = document.getElementById('mobileButtons');
    const pondSection = document.getElementById('pondSection');
    
    toolsSection.classList.add('mobile-visible');
    mobileButtons.classList.add('hidden');
    pondSection.classList.add('hidden');
}

function hideDrawingTools() {
    const toolsSection = document.getElementById('toolsSection');
    const mobileButtons = document.getElementById('mobileButtons');
    const pondSection = document.getElementById('pondSection');
    
    toolsSection.classList.remove('mobile-visible');
    mobileButtons.classList.remove('hidden');
    pondSection.classList.remove('hidden');
}

// Handle window resize
window.addEventListener('resize', function() {
    setupCanvas();
});

// Initialize
setupCrossTabSync();
loadPondItems();

// Enhanced real-time updates - check for changes every second
setInterval(syncDrawings, 1000);

// Also sync when the page becomes visible again
document.addEventListener('visibilitychange', function() {
    if (!document.hidden) {
        syncDrawings();
    }
});

// Sync when window gains focus
window.addEventListener('focus', syncDrawings);
</script>
